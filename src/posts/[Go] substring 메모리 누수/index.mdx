---
title: 'substring 메모리 누수'
date: 2026-01-31
desc: 내부 구현부터 프로덕션 적용까지
thumbnail: /team-member-1.jpeg
category: Go
open: true
---

## 도입

Go 에서 문자열 슬라이싱은 간편하고 직관적입니다.
`s[:10]` 처럼 원하는 범위를 잘라내면 새 문자열이 만들어진 것 같지만, 실제로는 그렇지 않습니다.

실무에서 흔히 발생하는 시나리오를 예로 들어보겠습니다.
로그 메시지에서 UUID(36자)만 추출하여 저장하는 상황입니다.
로그 한 줄이 수 KB 에서 수 MB 에 달할 수 있는데, 정작 필요한 건 앞부분 36바이트뿐입니다.
이 때 단순히 `log[:36]` 으로 잘라서 저장하면 어떤 일이 벌어질까요?

## Go 문자열의 내부 구조

Go 의 문자열은 내부적으로 두 개의 필드로 구성된 구조체입니다.
`reflect.StringHeader` 를 통해 확인할 수 있습니다.

```go
type StringHeader struct {
	Data uintptr // backing byte array 를 가리키는 포인터
	Len  int     // 문자열의 길이
}
```

즉, Go 의 문자열은 **실제 바이트 데이터(backing byte array)에 대한 읽기 전용 뷰**입니다.
문자열 값 자체를 가지고 있는 것이 아니라 바이트 배열의 시작 주소와 길이만 들고 있는 것입니다.

아래 코드로 직접 확인해볼 수 있습니다.

```go
package main

import (
	"fmt"
	"reflect"
	"unsafe"
)

func main() {
	s := "Hello, Go substring!"
	hdr := (*reflect.StringHeader)(unsafe.Pointer(&s))
	fmt.Printf("Data: %x, Len: %d\n", hdr.Data, hdr.Len)
	// Data: 포인터 주소, Len: 20
}
```

여기서 핵심은 `Data` 필드가 문자열의 실제 바이트를 저장하는 배열을 **가리키는 포인터**라는 점입니다.

## 서브스트링이 메모리 누수를 일으키는 이유

Go 에서 문자열 슬라이싱 `s[a:b]` 은 새로운 바이트 배열을 할당하지 않습니다.
원본 문자열과 **동일한 backing byte array 를 공유**하면서 `Data` 포인터의 오프셋과 `Len` 값만 달라집니다.

```bash
원본 문자열 s (len=1000)
┌───────────────────────────────────────────────┐
│  backing byte array (1000 bytes)              │
└───────────────────────────────────────────────┘
▲
│ Data 포인터
┌──────────┐
│ s        │
│ Len=1000 │
└──────────┘

서브스트링 sub := s[:36]
┌───────────────────────────────────────────────┐
│  backing byte array (1000 bytes)  ← 여전히 전체  │
└───────────────────────────────────────────────┘
▲
│ Data 포인터 (같은 주소)
┌──────────┐
│ sub      │
│ Len=36   │
└──────────┘
```

`sub` 의 길이는 36이지만, 이 문자열이 살아 있는 한 원본의 1000바이트 backing array 전체가 GC 에 의해 해제되지 못합니다.
36바이트만 사용하면서 나머지 964바이트가 불필요하게 메모리에 남게 되는 것입니다.

로그 메시지처럼 원본이 수 KB~MB 인 경우, 이런 서브스트링을 수천 개 저장하면 메모리 사용량이 눈에 띄게 증가할 수 있습니다.

## 메모리 누수 케이스

아래 코드는 로그에서 UUID 를 추출하여 store 에 저장하는 함수입니다.

```go
func (s store) handleLog(log string) error {
	if len(log) < 36 {
		return errors.New("log is not correctly formatted")
	}

	uuid := log[:36]
	s.store(uuid)

	// 필요한 작업을 수행
}
```

이 코드에서 `uuid` 는 `log` 의 앞 36바이트를 슬라이싱한 서브스트링입니다.
하지만 앞서 살펴본 것처럼 `uuid` 는 `log` 전체의 backing array 를 참조합니다.

`s.store(uuid)` 를 통해 `uuid` 가 store 에 장기 저장되면,
원본 `log` 문자열 전체가 GC 대상에서 제외됩니다.
예를 들어 로그 한 줄이 1KB 라면, UUID 36바이트를 저장할 때마다 1KB 가 해제되지 않는 셈입니다.
수십만 건의 로그를 처리하면 수백 MB 의 메모리가 누수될 수 있습니다.

## 해결 방법 1: `string([]byte(...))` 변환

가장 직관적인 해결 방법은 서브스트링을 **새로운 backing array 로 복사**하는 것입니다.

```go
func (s store) handleLog(log string) error {
	if len(log) < 36 {
		return errors.New("log is not correctly formatted")
	}

	uuid := string([]byte(log[:36]))
	s.store(uuid)

	// ...
}
```

`[]byte(log[:36])` 은 서브스트링의 바이트를 **새로운 바이트 슬라이스**로 복사합니다.
이후 `string(...)` 으로 다시 문자열로 변환하면, 원본 backing array 와는 완전히 분리된 새로운 문자열이 생성됩니다.

이제 `uuid` 는 36바이트짜리 독립적인 backing array 를 가지므로,
원본 `log` 는 `handleLog` 함수가 종료되면 GC 에 의해 정상적으로 회수됩니다.

## 해결 방법 2: `strings.Clone()` (Go 1.20)

Go 1.20 에서 도입된 `strings.Clone()` 함수를 사용하면 더 명시적으로 문자열을 복사할 수 있습니다.

```go
func (s store) handleLog(log string) error {
	if len(log) < 36 {
		return errors.New("log is not correctly formatted")
	}

	uuid := strings.Clone(log[:36])
	s.store(uuid)

	// ...
}
```

`strings.Clone` 의 내부 구현은 다음과 같습니다.

```go
// Clone returns a fresh copy of s.
// It guarantees to make a copy of s into a new allocation,
// which can be important when retaining only a small substring
// of a much larger string.
func Clone(s string) string {
	if len(s) == 0 {
		return ""
	}
	b := make([]byte, len(s))
	copy(b, s)
	return unsafe.String(&b[0], len(b))
}
```

내부적으로 `make([]byte, len(s))` 로 새 바이트 슬라이스를 할당하고 `copy` 로 내용을 복사합니다.
앞서 소개한 `string([]byte(...))` 방식과 원리는 동일하지만, 함수명 자체가 의도를 명확히 드러내므로 코드 가독성이 더 좋습니다.

> `strings.Clone` 의 주석에서도 "retaining only a small substring of a much larger string" 케이스를 명시적으로 언급하고 있습니다.

## 벤치마크로 확인하기

세 가지 방식의 성능을 벤치마크로 비교해보겠습니다.

```go
package main

import (
	"strings"
	"testing"
)

var longLog = strings.Repeat("a", 10000) // 10KB 로그

func BenchmarkSubstring(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = longLog[:36]
	}
}

func BenchmarkStringByteConversion(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = string([]byte(longLog[:36]))
	}
}

func BenchmarkStringsClone(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = strings.Clone(longLog[:36])
	}
}
```

- `BenchmarkSubstring` : 단순 슬라이싱으로 메모리 할당이 발생하지 않지만, backing array 전체를 참조합니다.
- `BenchmarkStringByteConversion` : 새 바이트 슬라이스 할당 + 복사가 발생합니다.
- `BenchmarkStringsClone` : 마찬가지로 새 할당 + 복사가 발생합니다.

`ReportAllocs()` 를 통해 각 벤치마크의 메모리 할당 횟수와 크기를 확인할 수 있습니다.
단순 슬라이싱은 할당이 0이지만, 나머지 두 방식은 36바이트의 할당이 1회 발생합니다.
성능 차이는 미미하며, 메모리 누수를 방지하는 이점이 훨씬 큽니다.

## 정리

Go 의 문자열 슬라이싱은 새로운 문자열을 만드는 것이 아니라, 원본 backing array 를 공유하는 뷰를 생성합니다.
따라서 서브스트링을 장기 저장하면 원본 문자열 전체가 GC 되지 못하는 메모리 누수가 발생할 수 있습니다.

특히 캐시나 맵에 서브스트링을 장기 저장하거나, 로그처럼 원본이 큰 문자열을 반복 처리할 때 주의가 필요합니다. 이런 경우 `string([]byte(...))` 변환이나 `strings.Clone()` 으로 서브스트링을 원본으로부터 분리하세요.

##### ref

- [100 Go Mistakes and How to Avoid Them - #26 Slices and memory leaks](https://100go.co/)
- [strings.Clone - Go 공식 문서](https://pkg.go.dev/strings#Clone)
