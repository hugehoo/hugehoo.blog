---
title: '[Go] race condition in append()'
date: 2026-02-08
desc: 슬라이스 capacity 에 따라 달라지는 append 의 동작
thumbnail: /team-member-1.jpeg
category: Go
open: true
---

## 도입

아래 두 코드를 보세요. 거의 동일해 보이지만, 하나는 data race 가 발생하고 다른 하나는 발생하지 않습니다.

```go
// 예제 1: data race 없음
s := make([]int, 1)

go func() {
    s1 := append(s, 2)
    fmt.Println(s1)
}()

go func() {
    s2 := append(s, 3)
    fmt.Println(s2)
}()
```

```go
// 예제 2: data race 발생!
s := make([]int, 0, 1)

go func() {
    s1 := append(s, 2)
    fmt.Println(s1)
}()

go func() {
    s2 := append(s, 3)
    fmt.Println(s2)
}()
```

차이점은 `make([]int, 1)` 과 `make([]int, 0, 1)` 뿐입니다.
왜 이런 차이가 발생할까요?

## Race Detector 로 확인하기

먼저 실제로 race condition 이 발생하는지 확인해보겠습니다.

### 예제 1: data race 없음

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    s := make([]int, 1)

    go func() {
        s1 := append(s, 2)
        fmt.Println(s1)
    }()

    go func() {
        s2 := append(s, 3)
        fmt.Println(s2)
    }()

    time.Sleep(time.Second)
}
```

```bash
$ go run -race main.go
[0 2]
[0 3]
```

race detector 가 아무런 경고도 출력하지 않습니다.

### 예제 2: data race 발생

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    s := make([]int, 0, 1)

    go func() {
        s1 := append(s, 2)
        fmt.Println(s1)
    }()

    go func() {
        s2 := append(s, 3)
        fmt.Println(s2)
    }()

    time.Sleep(time.Second)
}
```

```bash
$ go run -race main.go
==================
WARNING: DATA RACE
Write at 0x00c0000b8000 by goroutine 7:
  main.main.func2()
      /path/to/main.go:16 +0x6c

Previous write at 0x00c0000b8000 by goroutine 6:
  main.main.func1()
      /path/to/main.go:11 +0x6c

Goroutine 7 (running) created at:
  main.main()
      /path/to/main.go:14 +0xc4

Goroutine 6 (running) created at:
  main.main()
      /path/to/main.go:9 +0x90
==================
[3]
[3]
Found 1 data race(s)
exit status 66
```

두 goroutine 이 **같은 메모리 주소** (`0x00c0000b8000`) 에 동시에 쓰기를 시도하여 race condition 이 발생했습니다.

## Slice 내부 구조

이 현상을 이해하려면 먼저 Go slice 의 내부 구조를 알아야 합니다.

Go 의 slice 는 내부적으로 세 개의 필드로 구성됩니다.

```go
type slice struct {
    array unsafe.Pointer  // backing array 를 가리키는 포인터
    len   int             // 현재 길이
    cap   int             // 용량 (backing array 의 크기)
}
```

### make([]int, 1) 의 메모리 구조

`make([]int, 1)` 은 길이가 1이고 용량도 1인 슬라이스를 생성합니다.

```bash
┌─────────────────┐     ┌─────────┐
│ ptr ──────────────────→│ [0]     │ ← 이미 사용 중
│ len: 1          │     └─────────┘
│ cap: 1          │      backing array
└─────────────────┘      (꽉 참!)
   slice header
```

backing array 가 이미 가득 찼습니다 (`len == cap`).

### make([]int, 0, 1) 의 메모리 구조

`make([]int, 0, 1)` 은 길이가 0이고 용량이 1인 슬라이스를 생성합니다.

```bash
┌─────────────────┐     ┌─────────┐
│ ptr ──────────────────→│ [_]     │ ← 빈 슬롯!
│ len: 0          │     └─────────┘
│ cap: 1          │      backing array
└─────────────────┘      (여유 있음)
   slice header
```

backing array 에 아직 여유 공간이 있습니다 (`len < cap`).

## append() 의 동작 방식

`append` 함수는 슬라이스에 요소를 추가할 때 **현재 용량에 여유가 있는지** 확인합니다.

```bash
append(slice, element)
        │
        ▼
    len < cap?
   ╱         ╲
 YES          NO
  │            │
  ▼            ▼
기존 배열에    새 배열 할당
직접 쓰기     (더 큰 capacity)
  │            │
  ▼            ▼
같은 메모리   독립된 메모리
```

### 예제 1: 새 배열이 할당되는 경우

`make([]int, 1)` 로 생성된 슬라이스는 `len == cap == 1` 입니다.
여기에 `append` 로 요소를 추가하면:

1. `len(1) < cap(1)` 인가? → **아니오**
2. 새로운 backing array 를 할당
3. 기존 요소를 복사
4. 새 요소를 추가

```bash
Goroutine 1: append(s, 2)
┌─────────────────┐     ┌─────────┬─────────┐
│ ptr ──────────────────→│ 0       │ 2       │ ← 새 배열!
│ len: 2          │     └─────────┴─────────┘
│ cap: 2          │
└─────────────────┘

Goroutine 2: append(s, 3)
┌─────────────────┐     ┌─────────┬─────────┐
│ ptr ──────────────────→│ 0       │ 3       │ ← 또 다른 새 배열!
│ len: 2          │     └─────────┴─────────┘
│ cap: 2          │
└─────────────────┘
```

각 goroutine 이 **서로 다른 메모리 영역**에 쓰기를 하므로 race condition 이 발생하지 않습니다.

### 예제 2: 같은 배열에 쓰는 경우

`make([]int, 0, 1)` 로 생성된 슬라이스는 `len == 0`, `cap == 1` 입니다.
여기에 `append` 로 요소를 추가하면:

1. `len(0) < cap(1)` 인가? → **예**
2. 기존 backing array 의 `array[len]` 위치에 직접 쓰기

```bash
Time →
─────────────────────────────────────────────────────
원본 슬라이스 s:
┌─────────────────┐     ┌─────────┐
│ ptr ──────────────────→│ [_]     │
│ len: 0          │     └─────────┘
│ cap: 1          │
└─────────────────┘

Goroutine 1:  read s.ptr ───────→ write array[0] = 2
                                          │
Goroutine 2:  read s.ptr ───────→ write array[0] = 3
                                          │
                                    ┌─────┴─────┐
                                    │ SAME ADDR │
                                    │  = RACE!  │
                                    └───────────┘
```

두 goroutine 이 **같은 메모리 주소** (`array[0]`) 에 동시에 쓰기를 시도합니다.
이것이 바로 race condition 입니다.

## 왜 이런 설계인가?

`append` 가 이렇게 동작하는 이유는 성능 때문입니다. 매번 새 배열을 할당하면 메모리 할당과 복사 비용이 발생하고 GC 부담도 늘어납니다. capacity 가 충분할 때 기존 배열을 재사용하면 이런 비용을 줄일 수 있습니다.

다만 이 최적화가 동시성 환경에서는 race condition 을 유발할 수 있습니다.

## 해결 방법

### 1. 슬라이스 복사 후 전달

goroutine 에 슬라이스를 전달하기 전에 명시적으로 복사합니다.

```go
func main() {
    s := make([]int, 0, 1)

    copySlice := func(src []int) []int {
        dst := make([]int, len(src))
        copy(dst, src)
        return dst
    }

    go func() {
        local := copySlice(s)
        s1 := append(local, 2)
        fmt.Println(s1)
    }()

    go func() {
        local := copySlice(s)
        s2 := append(local, 3)
        fmt.Println(s2)
    }()

    time.Sleep(time.Second)
}
```

### 2. Mutex 사용

공유 슬라이스에 대한 접근을 동기화합니다.

```go
func main() {
    s := make([]int, 0, 1)
    var mu sync.Mutex

    go func() {
        mu.Lock()
        s = append(s, 2)
        mu.Unlock()
        fmt.Println(s)
    }()

    go func() {
        mu.Lock()
        s = append(s, 3)
        mu.Unlock()
        fmt.Println(s)
    }()

    time.Sleep(time.Second)
}
```

### 3. Channel 사용

Go 의 철학인 "메모리를 공유하지 말고, 통신으로 메모리를 공유하라" 를 따릅니다.

```go
func main() {
    ch := make(chan int, 2)

    go func() {
        ch <- 2
    }()

    go func() {
        ch <- 3
    }()

    results := make([]int, 0, 2)
    for i := 0; i < 2; i++ {
        results = append(results, <-ch)
    }
    fmt.Println(results)
}
```

### 4. Full capacity 슬라이스 사용

독립적인 복사본이 필요하다면 `len == cap` 인 슬라이스를 사용합니다.

```go
// 이렇게 하면 append 시 항상 새 배열이 할당됨
s := make([]int, 1)  // len=1, cap=1
```

## 정리

Go 의 `append` 함수는 capacity 에 따라 동작이 달라집니다.

| 조건 | append 동작 | 동시성 안전성 |
|------|-------------|---------------|
| `len == cap` | 새 배열 할당 | 안전 (각자 독립적인 메모리) |
| `len < cap` | 기존 배열에 직접 쓰기 | **위험** (동일 메모리 공유) |

slice header 는 복사되지만 backing array 는 공유된다는 점, 그리고 `append` 의 동작이 capacity 에 따라 달라진다는 점을 기억하면 됩니다. 동시성 환경에서는 항상 `-race` 플래그로 테스트하세요.

<br/>

<hr/>

##### ref

- [100 Go Mistakes and How to Avoid Them - #69 Not being careful with append](https://100go.co/)
- [The Go Blog - Go Slices: usage and internals](https://go.dev/blog/slices-intro)
- [Go Data Race Detector](https://go.dev/doc/articles/race_detector)
