---
title: Redis-setnx 로 중복 요청 방지
date: 2025-11-30
desc: 따딱 블로킹
thumbnail: /team-member-1.jpeg
category: Redis
open: true
---

## 기존 문제: Get & Set 으로 중복 요청 체크
- 기존코드는 어쩌구어쩌구



## Redis SETNX 로 안전하게 중복 요청 방지하기

— Spin Lock도 아니고, Distributed Lock만도 아닌, Fail-Fast Soft Lock 이야기

실제 운영 환경에서 API가 짧은 시간 동안 여러 번 호출되는 상황은 매우 흔하다.
특히 포인트 전환, 결제 요청, 이벤트 참여와 같은 API는 짧은 시간 동안 여러 호출이 들어오면 중복 처리가 발생해 서비스에 문제를 만들 수 있다.

이번 글에서는 이런 요청을 안전하게 막는 데 자주 사용되는 Redis SETNX에 대해 다룬다.
그리고 우리가 흔히 오해하는 분산 락과 스핀락의 차이, master–slave 환경에서의 락 안정성,
그리고 TTL 없는 락의 위험성까지 포함해, 실무에서 꼭 알고 있어야 할 내용을 정리한다.


### 1. SETNX로 중복 요청을 막는 방법

Redis의 SETNX(SET if Not Exists)는 특정 key가 없을 경우에만 값을 설정하는 명령이다.

ok, err := rdb.SetNX(ctx, key, true, 1*time.Second).Result()


이 방식은 중복 요청을 막는 데 매우 효과적이다.
동일한 키로 1초 동안 여러 번 호출되면, 첫 요청만 성공하고 나머지는 실패한다.
이 구조를 흔히 “Fail-Fast” 방식이라고 부른다.

즉,

첫 번째 요청: SETNX 성공 → 처리 진행

이후 1초 내 요청: SETNX 실패 → 중복 요청 차단

이 패턴은 **스핀 락이 아니라 try-lock(또는 soft lock)**에 해당한다.

### 2. ReleaseLock은 필요할까?

중복 요청 방지 목적이라면 절대로 key를 delete해서는 안 된다.

많은 개발자가 다음과 같은 상황을 떠올린다.

“작업 끝났으니 key를 삭제해서 락을 해제해야 하지 않을까?”

그러나 중복 요청 방지에서는 DEL(key)가 오히려 문제다.

첫 요청 → SETNX 성공

작업 완료 후 key를 삭제

TTL이 남아 있어야 하는데 바로 삭제

같은 TTL 안에 들어온 두 번째 요청이 다시 SETNX 성공 → 중복 처리 발생

정리하면:

중복 요청 방지에서는 key를 삭제하지 않고, TTL로 자연스럽게 만료되는 것이 정답이다.

### 3. 이 방식은 스핀락인가?

많은 사람이 SETNX 기반 중복 방지를 스핀락(spin lock)과 혼동한다.
하지만 이는 완전히 다른 개념이다.

개념	동작 방식
Spin Lock	락이 풀릴 때까지 반복적으로 확인(루프 돌며 CPU 사용)
SETNX Soft Lock	락이 있으면 즉시 실패(Fail-Fast), 대기 없음

SETNX는 락이 있으면 바로 실패하고 종료하므로, CPU를 낭비하지 않는다.
즉,

“SETNX 기반 중복 요청 방지는 스핀락이 아니라 Fail-Fast Try-Lock이다.”

### 4. 분산 락(Distributed Lock)의 올바른 의미

“분산 락”이라는 말에서 Redis 인스턴스가 여러 대일 때 락이 분산되어 걸린다고 오해하는 경우가 많다.
하지만 분산 락은 Redis 인스턴스 수와 상관이 없다.

분산 락의 정확한 의미는 다음과 같다.

여러 개의 애플리케이션 서버가 동일한 자원에 접근하는 것을 동기화하기 위해 사용하는 락

즉, Redis가 단 1대만 있어도
여러 서버(예: 서버 A, B, C)가 같은 key를 기준으로 락을 이용한다면
그것 자체가 이미 분산 락이다.

### 5. Master–Slave 환경에서는 락이 어떻게 동작할까?

Redis의 master–slave 구조에서:

SETNX와 같은 write는 항상 master에서만 이루어진다.

slave는 단지 master의 데이터를 replication 받아 읽기만 한다.

문제는 replication이 비동기적이라는 점이다.

이 때문에 다음과 같은 상황이 발생할 수 있다:

서버 A → master에 SETNX 성공

slave는 아직 replication을 받지 않아 락이 없음

서버 B가 slave를 조회하면 “락 없음”으로 판단

동기화 문제가 발생

즉,

락 관련 작업(GET/SETNX/DEL)은 반드시 master에서만 해야 한다.

중복 요청 방지에서는 읽기 자체가 필요 없기 때문에 문제가 적지만,
master–slave 구조에서 락을 제대로 이해하는 것은 매우 중요하다.

### 6. 락을 영구적으로 잡아도 될까?

이론적으로는 "그 key에 절대 다시 요청이 오지 않는다면" 문제가 없다.
그러나 실서비스에서는 이것이 매우 위험한 안티패턴이다.

그 이유는 다음과 같다:

락이 영구적으로 걸리는 상황은 대부분 “버그”에서 발생함

언제든 새로운 요청이 들어올 가능성이 있음

디버깅이 어려워짐

운영 중 장애 대응이 거의 불가능해짐

따라서:

락은 반드시 TTL을 가져야 한다.
영구 상태가 필요하면 “락”이 아니라 “플래그”로 별도 관리해야 한다.
