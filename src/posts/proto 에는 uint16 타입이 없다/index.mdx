---
title: proto 에는 uint16 타입이 없다
date: 2025-10-20
desc: 당황당황하지마
thumbnail: /team-member-1.jpeg
ogImage: /b-tree-2.png
category: 'proto'
open: false
---
# 왜 만들려 하나

## 서론

Protocol Buffers(protobuf)를 사용하다 보면 한 가지 의아한 점을 발견하게 됩니다. Go나 C++ 같은 언어에서는 `uint16` 타입을 자주 사용하는데, 왜 `.proto` 파일에는 이 타입이 없을까요?

Protocol Buffers는 Google이 개발한 언어 중립적인 데이터 직렬화 포맷으로, 핵심 목표는 **언어 간 호환성**과 **네트워크 전송 효율성**입니다. 이 글에서는 왜 `uint16`이 제외되었는지, 그리고 실무에서 어떻게 대응해야 하는지 깊이 있게 살펴보겠습니다.

## 본론

### Protocol Buffers가 지원하는 정수 타입

먼저 Protocol Buffers v3에서 지원하는 정수 타입을 살펴보겠습니다:

**Unsigned 타입:**
- `uint32`: 0 ~ 4,294,967,295
- `uint64`: 0 ~ 18,446,744,073,709,551,615

**Signed 타입:**
- `int32`: -2,147,483,648 ~ 2,147,483,647
- `int64`: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
- `sint32`, `sint64`: ZigZag 인코딩으로 음수를 효율적으로 표현

**고정 크기 타입:**
- `fixed32`: 항상 4바이트
- `fixed64`: 항상 8바이트

보시다시피 8비트나 16비트 단위의 타입은 제공되지 않습니다.

### uint16이 없는 세 가지 핵심 이유

#### 1. Varint 인코딩의 효율성

Protocol Buffers는 네트워크 전송 효율성을 위해 **varint(가변 길이 정수) 인코딩**을 사용합니다. 이 방식의 특징은 다음과 같습니다:

- 작은 숫자는 적은 바이트 사용 (1~3바이트)
- 큰 숫자는 더 많은 바이트 사용
- 실제 값의 크기에 따라 동적으로 조정

예를 들어, `uint16` 범위의 값(0~65,535)을 `uint32`로 저장해도 varint 인코딩 덕분에 1~3바이트만 사용됩니다. 즉, **별도의 uint16 타입이 없어도 메모리나 네트워크 효율성 측면에서 차이가 없습니다**.

**하지만 주의할 점이 있습니다.** Varint 인코딩이 항상 효율적인 것은 아닙니다:

- `uint32` 최댓값(4,294,967,295)은 varint로 5바이트 사용
- `fixed32`는 항상 4바이트만 사용

따라서 **대부분의 값이 큰 범위에 분포한다면** `fixed32`나 `fixed64`를 사용하는 것이 더 효율적입니다. Protocol Buffers가 두 가지 옵션을 모두 제공하는 이유가 바로 이것입니다. 데이터의 분포 특성을 고려한 타입 선택이 중요합니다.

#### 2. 언어 간 호환성

Protocol Buffers의 가장 큰 강점은 다양한 프로그래밍 언어 간의 원활한 데이터 교환입니다. 그런데 각 언어마다 지원하는 정수 타입이 다릅니다:

- **Go**: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64` 모두 지원
- **Java**: 기본적으로 unsigned 타입이 없으며, `short`(16비트)도 signed만 존재
- **JavaScript**: 모든 숫자가 64비트 부동소수점으로 표현

만약 protobuf가 `uint16`을 지원했다면 Java나 JavaScript에서 이를 적절히 매핑할 방법이 없었을 것입니다. 따라서 **모든 언어에서 안전하게 사용 가능한 최소 공통 타입만 제공**하는 것이 합리적입니다.

#### 3. 설계의 단순성

Google은 Protocol Buffers를 설계하면서 다음 원칙을 따랐습니다:

- 타입 수를 최소화하여 단순성 유지
- 대부분의 실제 사용 사례를 커버할 수 있는 타입만 선택
- 불필요한 복잡성 제거

`uint32`와 `uint64`만으로도 충분히 다양한 범위를 표현할 수 있고, varint 인코딩으로 효율성도 확보되므로, 더 세분화된 타입은 필요하지 않다고 판단한 것입니다.

### sint32와 int32: 음수 처리의 차이점

음수를 다룰 때 `int32`와 `sint32` 중 어떤 것을 선택해야 할까요? 핵심은 **ZigZag 인코딩** 여부입니다:

**int32의 동작:**
- 음수를 그대로 인코딩
- 음수는 항상 5바이트 사용 (큰 unsigned 값처럼 취급)
- 예: `-1`은 `4294967295`로 인코딩되어 5바이트

**sint32의 동작:**
- ZigZag 인코딩 사용
- `-1`은 1바이트, `-64`는 2바이트로 효율적
- 부호를 최하위 비트로 옮겨 `-1`을 `1`로, `-2`를 `3`으로 변환

```
ZigZag 인코딩 예시:
0 → 0
-1 → 1
1 → 2
-2 → 3
2 → 4
```

**언제 sint32를 사용해야 할까요?**
- 음수 값이 자주 등장하는 경우
- 음수의 절댓값이 작은 경우 (예: -100 ~ 100 범위)
- 델타 값이나 차분 데이터를 저장할 때

반면 대부분 양수이거나 음수가 드물다면 `int32`가 더 적합합니다.

### 실무에서의 대응 방법

그렇다면 실제로 `uint16` 범위의 값을 다루고 싶을 때는 어떻게 해야 할까요?

**Proto 파일 정의:**

```protobuf
message GetBalanceResponse {
    int64 device_id = 1;
    uint32 balance = 2;  // uint16 대신 uint32 사용
}
```

**Go 코드에서의 변환:**

```go
// Proto에서 받은 값을 uint16으로 변환
if response.Balance > 65535 {
    return fmt.Errorf("balance exceeds uint16 range")
}
tokenAmount := uint16(response.Balance)
```

이 방식의 장점:
- Varint 인코딩으로 작은 값은 여전히 1~3바이트만 사용
- 향후 값 범위 확장이 필요할 때 proto 파일 수정 없이 대응 가능
- 모든 언어에서 안전하게 사용 가능

### 스키마 진화와 타입 변경

프로덕션 환경에서 스키마를 진화시킬 때, 타입 변경이 안전한지 궁금할 수 있습니다. 특히 `uint32`를 `uint64`로 변경하면 하위 호환성이 보장될까요?

**안전한 타입 변경:**
- `int32` ↔ `int64`, `uint32` ↔ `uint64`
- `sint32` ↔ `sint64`
- `string` ↔ `bytes`

**위험한 타입 변경:**
- `uint32` → `int32` (큰 값이 음수로 해석될 수 있음)
- `fixed32` → `int32` (인코딩 방식이 다름)
- `int32` → `sint32` (인코딩 방식이 다름)

`uint32`를 `uint64`로 변경하면:
- **기존 클라이언트**: 하위 32비트만 읽음 (기존 데이터 정상 처리)
- **새 클라이언트**: 전체 64비트를 읽음 (확장된 범위 지원)
- **전방/후방 호환성 모두 유지**

단, 반대 방향(`uint64` → `uint32`)은 데이터 손실 위험이 있으므로 주의가 필요합니다.

**필드 제거 시 베스트 프랙티스:**

```protobuf
message User {
    string name = 1;
    reserved 2;  // 삭제된 필드 번호 예약
    reserved "old_email";  // 삭제된 필드명 예약
    string email = 3;
}
```

필드 번호를 `reserved`로 예약하면 나중에 실수로 같은 번호를 재사용하는 것을 방지할 수 있습니다.

## 결론

Protocol Buffers에 `uint16` 타입이 없는 것은 결함이 아니라 신중한 설계 결정의 결과입니다. Varint 인코딩의 효율성, 언어 간 호환성, 그리고 설계의 단순성이라는 세 가지 핵심 원칙을 지키기 위한 선택이었습니다.

실무에서는 다음과 같은 전략을 취하는 것이 좋습니다:

1. **타입 선택**: 데이터 분포에 따라 varint(`uint32`, `int32`) 또는 fixed(`fixed32`) 선택
2. **음수 처리**: 음수가 자주 등장하고 절댓값이 작다면 `sint32`/`sint64` 사용
3. **애플리케이션 레벨 변환**: 필요시 `uint32`를 `uint16`으로 변환하되 범위 검증 수행
4. **스키마 진화**: 안전한 타입 변경 규칙을 따르고, 삭제된 필드는 `reserved`로 보호

이러한 접근법은 protobuf의 철학인 "네트워크 효율성과 언어 독립성"을 해치지 않으면서도 각 언어의 타입 시스템을 효과적으로 활용할 수 있는 실용적인 방법입니다.

Protocol Buffers를 처음 접하면 제약처럼 느껴질 수 있지만, 이러한 설계 결정들이 결국 더 안정적이고 유지보수하기 쉬운 시스템을 만드는 데 기여한다는 점을 이해하는 것이 중요합니다.