---
title: 'grpc-go: add test coverages of ExitIdle'
date: 2025-09-07
desc: 'grpc-go: add test coverages of ExitIdle #8375'
thumbnail: /team-member-1.jpeg
category: grpc-go, opensource
open: true
---
π”— PR - https://github.com/grpc/grpc-go/pull/8375

## 1. PRμ λ©μ 
κΈ°μ΅΄μ— μ‘μ„±λμ§€ μ•μ•λ **ExitIdle** κ΄€λ ¨ λ©”μ„λ“μ λ‹¨μ„ ν…μ¤νΈλ¥Ό μ‘μ„±ν•μ—¬ ν…μ¤νΈ μ»¤λ²„λ¦¬λ¥Ό μ¶”κ°€ν•λ” PR μ…λ‹λ‹¤. μ—¬κΈ°μ„ ExitIdle μ΄ λ¬΄μ—‡μ„ μλ―Έν•λ”μ§€ μ•„λμ—μ„ μ„¤λ…ν•κ² μµλ‹λ‹¤.
μ΄λ² PR μ—μ„λ” BalancerGroup μ ExitIdle μ΄ λ‹¤μ–‘ν• μ‹λ‚λ¦¬μ¤μ—μ„ μ¬λ°”λ¥΄κ² μ²λ¦¬λλ”μ§€ κ²€μ¦ν•κΈ° μ„ν• ν…μ¤νΈ μ½”λ“λ¥Ό μ¶”κ°€ν•©λ‹λ‹¤.

### 1-1. ExitIdle μ΄λ€?
ExitIdleμ€ gRPC ν΄λΌμ΄μ–ΈνΈκ°€ μ ν΄(idle) μƒνƒμ—μ„ λ²—μ–΄λ‚(exit) λ‹¤μ‹ μ—°κ²°μ„ ν™μ„±ν™”ν•λ” λ©”μ»¤λ‹μ¦μ„ μλ―Έν•©λ‹λ‹¤.
gRPC ν΄λΌμ΄μ–ΈνΈλ” μ„λ²„μ™€μ μ—°κ²°μ„ μ μ§€ν•μ§€λ§, μΌμ • μ‹κ°„ λ™μ• μ”μ²­μ΄ μ—†μΌλ©΄ λ¦¬μ†μ¤λ¥Ό μ μ•½ν•κΈ° μ„ν•΄ μ—°κ²°μ΄ μ ν΄ μƒνƒλ΅ μ „ν™λ©λ‹λ‹¤.
μ ν΄ μƒνƒμ—μ„λ” μ„λ²„μ™€μ μ—°κ²°μ΄ λκΈ°κ±°λ‚, μ”μ²­μ΄ μ™”μ„ λ• μ¦‰μ‹ μ²λ¦¬ν•  μ μ—†λ” μƒνƒκ°€ λ  μ μμµλ‹λ‹¤.
ExitIdleμ€ μƒλ΅μ΄ μ”μ²­μ΄ λ“¤μ–΄μ™”μ„ λ•, ν΄λΌμ΄μ–ΈνΈκ°€ μ ν΄ μƒνƒμ—μ„ λ²—μ–΄λ‚ μ„λ²„μ™€μ μ—°κ²°μ„ μ¬κ°ν•κ³ , μ •μƒμ μΈ μ”μ²­ μ²λ¦¬ μƒνƒλ΅ λμ•„κ°€λ„λ΅ νΈλ¦¬κ±°ν•©λ‹λ‹¤.

`subConn` μ€ gRPC client μ™€ ν•λ‚μ νΉμ • μ„λ²„ κ°„μ λ‹¨μΌ μ—°κ²°μ„ μλ―Έν•λ” κ°λ…μΌλ΅, IDLE μƒνƒμ SubConn μ€ **subConn.Connect**κ°€ νΈμ¶λ  λ•κΉμ§€ μλ™μΌλ΅ μ¬μ—°κ²°ν•μ§€ μ•μµλ‹λ‹¤.
gRPC μ default idleTimeout μ€ 30λ¶„μΌλ΅ μ±„λ„μ— μ§„ν–‰ μ¤‘μΈ RPCκ°€ μ—†κ³  μƒλ΅μ΄ RPCκ°€ μ‹μ‘λμ§€ μ•μΌλ©΄ μ±„λ„μ€ idle λ¨λ“λ΅ μ „ν™λ©λ‹λ‹¤.
μ΄λ• name resolverμ™€ load balancerκ°€ μΆ…λ£λ©λ‹λ‹¤.
λ°λ€λ΅ ExitIdle μ΄ νΈλ¦¬κ±° λλ©΄ name resolver μ™€ load balancer μ—­μ‹ μ¬μ‹μ‘ λ©λ‹λ‹¤.

``` go
func defaultDialOptions() dialOptions {
	return dialOptions{
		copts: transport.ConnectOptions{
			ReadBufferSize:  defaultReadBufSize,
			WriteBufferSize: defaultWriteBufSize,
			UserAgent:       grpcUA,
			BufferPool:      mem.DefaultBufferPool(),
		},
		bs:                       internalbackoff.DefaultExponential,
		idleTimeout:              30 * time.Minute,
		defaultScheme:            "dns",
		maxCallAttempts:          defaultMaxCallAttempts,
		useProxy:                 true,
		enableLocalDNSResolution: false,
	}
}
```

<details>
<summary>gRPC μ channel μ΄λ€ </summary>
`μ±„λ„(channel)` μ€ ν΄λΌμ΄μ–ΈνΈκ°€ μ„λ²„μ— RPC(remote procedure call) λ¥Ό λ³΄λ‚Ό μ μλ” ν†µμ‹  ν†µλ΅ μ—­ν• μ„ ν•λ” λ…Όλ¦¬μ  μ—°κ²°μ„ μλ―Έν•©λ‹λ‹¤.
μ—¬κΈ°μ„ μ±„λ„μ€ λ‹¨μν ν•λ‚μ tcp μ—°κ²°μ„ μλ―Έν•λ” κ²ƒμ΄ μ•„λ‹, μ—¬λ¬ κΈ°λ¥μ„ μ¶”μƒν™”ν•κ³  κ΄€λ¦¬ν•λ” μƒμ„ κ°λ…μΌλ΅ μ•„λμ μ—­ν• μ„ μν–‰ν•  μ μμµλ‹λ‹¤.

> - μ—°κ²° κ΄€λ¦¬ : μ±„λ„μ€ ν• κ° μ΄μƒμ λ¬Όλ¦¬μ μΈ TCP μ—°κ²°(subConn) μ„ κ΄€λ¦¬
> - λ¶€ν• λ¶„μ‚° : μ—¬λ¬ μ„λ²„ μΈμ¤ν„΄μ¤μ— λ¶€ν• λ¶„μ‚°μ„ μ²λ¦¬
> - μ—°κ²° μ¬μ‹λ„: μ—°κ²°μ΄ λμ–΄μ΅μ„ λ• μλ™ μ¬μ—°κ²° μ‹λ„.
</details>

``` go
type ExitIdler interface {
    // ExitIdleμ€ LB μ •μ±…μ—κ² λ°±μ—”λ“μ™€ μ¬μ—°κ²°ν•κ±°λ‚
    // IDLE μƒνƒμ—μ„ λ²—μ–΄λ‚λ„λ΅ μ§€μ‹ν•©λ‹λ‹¤
    ExitIdle()
}
```

μ •λ¦¬ν•μλ©΄ ExitIdle μ€ μ ν΄ μƒνƒμΈ ν΄λΌμ΄μ–ΈνΈκ°€ ν™μ„±ν™”λμ–΄ μ¬μ”μ²­μ„ λ³΄λ‚΄λ” νΈλ¦¬κ±° μ—­ν• μ„ μ κ³µν•©λ‹λ‹¤.


### 1-2. BalancerGroup μ΄λ€?
`balancergroup`μ€ gRPC ν΄λΌμ΄μ–ΈνΈ μΈ΅μ—μ„ μ—¬λ¬ λ°±μ—”λ“ **μ—°κ²°μ„ κ΄€λ¦¬**ν•κ³  μ”μ²­μ„ μ μ ν• **λ°±μ—”λ“λ΅ λ¶„μ‚°**ν•κΈ° μ„ν• λ¶€ν• λ¶„μ‚° κµ¬μ„± μ”μ†μ…λ‹λ‹¤.
ν•λ‚μ gRPC μ„λΉ„μ¤λ” μ—¬λ¬ μ„λ²„(λ°±μ—”λ“)λ΅ κµ¬μ„±λ  μ μμΌλ©°, balancergroup μ€ μ΄λ¬ν• μ„λ²„λ¥Ό κ·Έλ£Ήν™”ν•μ—¬ ν¨μ¨μ μΈ λ¶€ν• λ¶„μ‚°μ„ κ°€λ¥μΌ€ ν•©λ‹λ‹¤.
ν΄λΌμ΄μ–ΈνΈμ™€ ν†µμ‹ ν•  μ—¬λ¬ μ„λ²„ μ¤‘μ—μ„ ν„μ¬ μ”μ²­μ„ λ³΄λ‚Ό μµμ μ μ„λ²„λ¥Ό μ„ νƒν•λ” λ΅μ§μ„ κµ¬ν„ν•λ©°, μ΄λ” round robin,least-connection κ°™μ€ λ‹¤μ–‘ν• λ¶€ν• λ¶„μ‚° μ „λµμ„ μ„ νƒν•  μ μμµλ‹λ‹¤.
balancergroup μ€ ν΄λΌμ΄μ–ΈνΈ-μ„λ²„ κ°„ μ—¬λ¬ κ°μ λ¬Όλ¦¬μ  μ—°κ²°μ„ λ…Όλ¦¬μ μΈ ν•λ‚μ λ‹¨μ„λ΅ κ΄€λ¦¬ν•μ—¬, λ΅λ“ λ°Έλ°μ‹± μ •μ±…μ΄ λ³µμ΅ν• μ—°κ²° μƒνƒλ¥Ό κ°λ°μκ°€ μ§μ ‘ λ‹¤λ£¨μ§€ μ•κ³ λ„ μ¶”μƒν™”λ λ°±μ—”λ“ κ·Έλ£Ήμ— λ€ν• κ²°μ •μ„ λ‚΄λ¦΄ μ μλ” μ—­ν• μ„ ν•©λ‹λ‹¤.

`ExitIdle` κ³Ό `BalancerGroup` λ” ν΄λΌμ΄μ–ΈνΈ μΈ΅ λ΅λ“ λ°Έλ°μ‹±μ—μ„ ν•¨κ» λ™μ‘ν•©λ‹λ‹¤. μ ν΄ μƒνƒμ ν΄λΌμ΄μ–ΈνΈκ°€ ν™μ„±ν™”λμ–΄ μ”μ²­μ„ λ³΄λ‚΄κΈ° μ„ν• νΈλ¦¬κ±° μ—­ν• μ„ ExitIdle μ΄ μ κ³µν•κ³ ,
BalancerGroup μ€ ν™μ„±ν™”λ ν΄λΌμ΄μ–ΈνΈκ°€ μ”μ²­μ„ λ³΄λ‚Ό λ• μµμ μ μ„λ²„λ¥Ό μ„ νƒν•  μλ„λ΅ λ¶€ν• λ¶„μ‚° μ‘μ—…μ„ μ„¤μ • μ—­ν• μ„ μν–‰ν•©λ‹λ‹¤.

## 2. PR - ν…μ¤νΈ μΌ€μ΄μ¤ μ‘μ„±
BalancerGroup κ΄€λ ¨ ν…μ¤νΈ μ‘μ„±:
### 2-1. TestBalancerGroup_UpdateClientConnState_AfterClose
BalancerGroupμ΄ λ‹«ν(Close) ν›„ UpdateClientConnState λ©”μ„λ“κ°€ νΈμ¶λμ„ λ•μ λ™μ‘μ„ κ²€μ¦ν•λ” ν…μ¤νΈλ΅,
BalancerGroup close ν›„μ—λ” λ” μ΄μƒ ν•μ„ balancer μ—κ² μƒνƒ μ—…λ°μ΄νΈ μ „νκ°€ λμ§€ μ•λ„λ΅ κ²€μ¦ν•©λ‹λ‹¤.

``` go
func (s) TestBalancerGroup_UpdateClientConnState_AfterClose(t *testing.T) {
	balancerName := t.Name()
	clientConnStateCh := make(chan struct{}, 1)

  // stub balancer λ“±λ΅
	stub.Register(balancerName, stub.BalancerFuncs{
	  // UpdateClientConnState νΈμ¶λ  λ• λ§λ‹¤ μ±„λ„μ— μ‹ νΈλ¥Ό λ³΄λ‚΄λ„λ΅ ν•¨
		UpdateClientConnState: func(_ *stub.BalancerData, _ balancer.ClientConnState) error {
			clientConnStateCh <- struct{}{}
			return nil
		},
	})

	bg := New(Options{
		CC:              testutils.NewBalancerClientConn(t), // ν…μ¤νΈμ© ν΄λΌμ΄μ–ΈνΈ μ—°κ²° μƒμ„±
		BuildOpts:       balancer.BuildOptions{},
		StateAggregator: nil,
		Logger:          nil,
	})

	bg.Add(testBalancerIDs[0], balancer.Get(balancerName))
	bg.Close() // BalancerGroup μ„ μΆ…λ£ μƒνƒλ΅ λ³€κ²½ -> bg μ— μ†ν•λ” balancer λ” μ ν΄ μƒνƒκ°€ λμ–΄μ•Ό ν•¨

	if err := bg.UpdateClientConnState(testBalancerIDs[0], balancer.ClientConnState{}); err != nil {
		t.Fatalf("Expected nil error, got %v", err)
	}

	select {
	case <-clientConnStateCh:
		t.Fatalf("UpdateClientConnState was called after BalancerGroup was closed")
	case <-time.After(defaultTestShortTimeout):
	}
}
```
UpdateClientConnState λ¥Ό νΈμ¶ν•λ©΄ clientConnStateCh μ±„λ„μ— μ‹ νΈκ°€ μ¤λ„λ΅ stub μ„ λ“±λ΅ν–κ³ , select λ¬Έμ„ μ‚¬μ©ν•μ—¬ ν•΄λ‹Ή μ±„λ„μ— μ‹ νΈκ°€ μ¤λ”μ§€ νΉμ€
defaultTestShortTimeout μ΄ μ§€λ‚λ©΄ μ •μƒμΆ…λ£ λλ„λ΅ λ‘κ°€μ§€ μΌ€μ΄μ¤λ¥Ό κ²€μ¦ν•©λ‹λ‹¤.
μΆ…λ£λ BalancerGroup μ—μ„ UpdateClientConnState λ¥Ό νΈμ¶ν•  μ μ—†λ” κ²ƒμ΄ μ •μƒ λ™μ‘μ΄κΈ° λ•λ¬Έμ— clientConnStateCh κ°€ μ‹ νΈλ¥Ό λ°›μΌλ©΄ ν…μ¤νΈλ” μ‹¤ν¨ν•©λ‹λ‹¤.
μ‹¤μ λ΅ UpdateClientConnState κµ¬ν„μ„ λ³΄λ©΄ balancer group μ΄ λ‹«ν ν›„μ—” nil μ„ λ¦¬ν„΄ν•μ—¬ graceful ν•κ² μ²λ¦¬λλ” κ²ƒμ„ ν™•μΈν•  μ μμµλ‹λ‹¤.

``` go
// UpdateClientConnState handles ClientState (including balancer config and
// addresses) from resolver. It finds the balancer and forwards the update.
func (bg *BalancerGroup) UpdateClientConnState(id string, s balancer.ClientConnState) error {
	bg.outgoingMu.Lock()
	defer bg.outgoingMu.Unlock()
	if bg.outgoingClosed {
		return nil
	}
	if config, ok := bg.idToBalancerConfig[id]; ok {
		return config.updateClientConnState(s)
	}
	return nil
}
```
<br/>

### 2-2. TestBalancerGroup_ResolverError_AfterClose
BalancerGroupμ΄ λ‹«ν ν›„ ResolverError λ©”μ„λ“κ°€ νΈμ¶ μ‹ λ™μ‘μ„ κ²€μ¦ν•λ” ν…μ¤νΈλ΅
BalancerGroup close ν›„μ—λ” λ” μ΄μƒ ν•μ„ balancer μ—κ² resolver μ—λ¬κ°€ μ „νλμ§€ μ•λ„λ΅ κ²€μ¦ν•©λ‹λ‹¤.
`ResolverErrorλ”` gRPCμ name resolution κ³Όμ •μ—μ„ λ°μƒν•λ” μ—λ¬λ¥Ό μ²λ¦¬ν•λ” λ©”μ„λ“μ…λ‹λ‹¤.
DNS μ΅°ν μ‹¤ν¨, Service Discovery μ¥μ• , λ„¤νΈμ›ν¬ μ—°κ²° λ¬Έμ  λ“±μ μƒν™©μ—μ„ name resolverκ°€ μ„λΉ„μ¤ μ΄λ¦„μ„ μ‹¤μ  μ„λ²„ μ£Όμ†λ΅ λ³€ν™ν•μ§€ λ»ν•  λ• νΈμ¶λ©λ‹λ‹¤.
ResolverErrorλ¥Ό νΈμ¶ν•λ©΄ resolveErrorCh μ±„λ„μ— μ‹ νΈκ°€ μ¤λ„λ΅ stubμ„ λ“±λ΅ν–κ³ 
select λ¬Έμ„ μ‚¬μ©ν•μ—¬ ν•΄λ‹Ή μ±„λ„μ— μ‹ νΈκ°€ μ¤λ”μ§€ νΉμ€ defaultTestShortTimeoutμ΄ μ§€λ‚λ©΄ μ •μƒμΆ…λ£ λλ„λ΅ λ‘κ°€μ§€ μΌ€μ΄μ¤λ¥Ό κ²€μ¦ν•©λ‹λ‹¤.
μΆ…λ£λ BalancerGroup μ—μ„ ResolverErrorκ°€ ν•μ„ balancerμ— μ „νλμ§€ μ•λ” κ²ƒμ΄ μ •μƒ λ™μ‘μ΄κΈ° λ•λ¬Έμ— resolveErrorChκ°€ μ‹ νΈλ¥Ό λ°›μΌλ©΄ ν…μ¤νΈλ” μ‹¤ν¨ν•©λ‹λ‹¤.

``` go
func (s) TestBalancerGroup_ResolverError_AfterClose(t *testing.T) {
	balancerName := t.Name()
	resolveErrorCh := make(chan struct{}, 1)

	stub.Register(balancerName, stub.BalancerFuncs{
		ResolverError: func(_ *stub.BalancerData, _ error) {
			resolveErrorCh <- struct{}{}
		},
	})

	bg := New(Options{
		CC:              testutils.NewBalancerClientConn(t),
		BuildOpts:       balancer.BuildOptions{},
		StateAggregator: nil,
		Logger:          nil,
	})

	bg.Add(testBalancerIDs[0], balancer.Get(balancerName))
	bg.Close()

	bg.ResolverError(errors.New("test error"))

	select {
	case <-resolveErrorCh:
		t.Fatalf("ResolverError was called on sub-balancer after BalancerGroup was closed")
	case <-time.After(defaultTestShortTimeout):
	}
}
```

ResolverError κµ¬ν„μ—μ„  balancer group μ΄ λ‹«ν ν›„μ—” early return μΌλ΅ graceful ν• μ²λ¦¬ν•λ” κ²ƒμ„ ν™•μΈν•  μ μμµλ‹λ‹¤.
``` go
// ResolverError handles name resolution errors from the name resolver.
func (bg *BalancerGroup) ResolverError(err error) {
    bg.outgoingMu.Lock()
    defer bg.outgoingMu.Unlock()
    if bg.outgoingClosed {
        return
    }
    for _, config := range bg.idToBalancerConfig {
        config.resolverError(err)
    }
}
```

### 2-3. TestBalancerGroup_ExitIdle_AfterClose

BalancerGroupμ΄ λ‹«ν ν›„ ExitIdle λ©”μ„λ“κ°€ νΈμ¶λμ„ λ•μ λ™μ‘μ„ κ²€μ¦ν•λ” ν…μ¤νΈ μ…λ‹λ‹¤.
BalancerGroup close ν›„μ—λ” λ” μ΄μƒ ν•μ„ balancer μ—κ² ExitIdle νΈμ¶μ΄ μ „νλμ§€ μ•λ„λ΅ κ²€μ¦ν•©λ‹λ‹¤. <br/>

ExitIdle μ κ°λ…μ„ νμ•…ν•λ©΄ μ‚¬μ‹¤ λ„λ¬΄λ‚ λ‹Ήμ—°ν• κ²€μ¦ μ½”λ“μ…λ‹λ‹¤.
ExitIdleμ€ μ ν΄ μƒνƒμ ν΄λΌμ΄μ–ΈνΈλ¥Ό ν™μ„±ν™”ν•μ—¬ μ„λ²„μ™€μ μ—°κ²°μ„ μ¬κ°ν•λ” κ²ƒμ΄ ν•µμ‹¬ λ©”μ»¤λ‹μ¦μΌλ΅,
μΌλ°μ μΌλ΅λ” μƒλ΅μ΄ RPC μ”μ²­μ΄ λ“¤μ–΄μ¤κ±°λ‚ λ…μ‹μ μΌλ΅ Connect() λ©”μ„λ“κ°€ νΈμ¶λ  λ• νΈλ¦¬κ±°λμ–΄ IDLE μƒνƒμ SubConn λ“¤μ΄ μ—°κ²°μ„ μ‹λ„ν•©λ‹λ‹¤.

``` go
func (s) TestBalancerGroup_ExitIdle_AfterClose(t *testing.T) {
	balancerName := t.Name()
	exitIdleCh := make(chan struct{}, 1)

	stub.Register(balancerName, stub.BalancerFuncs{
		ExitIdle: func(_ *stub.BalancerData) {
			exitIdleCh <- struct{}{}
		},
	})

	bg := New(Options{
		CC:              testutils.NewBalancerClientConn(t),
		BuildOpts:       balancer.BuildOptions{},
		StateAggregator: nil,
		Logger:          nil,
	})

	bg.Add(testBalancerIDs[0], balancer.Get(balancerName))
	bg.Close()
	bg.ExitIdle()

	select {
	case <-exitIdleCh:
		t.Fatalf("ExitIdle was called on sub-balancer even after BalancerGroup was closed")
	case <-time.After(defaultTestShortTimeout):
	}
}
```
ExitIdleμ„ νΈμ¶ν•λ©΄ exitIdleCh μ±„λ„μ— μ‹ νΈκ°€ μ¤λ„λ΅ stubμ„ λ“±λ΅ν–κ³ ,
select λ¬Έμ„ μ‚¬μ©ν•μ—¬ ν•΄λ‹Ή μ±„λ„μ— μ‹ νΈκ°€ μ¤λ”μ§€ νΉμ€ defaultTestShortTimeoutμ΄ μ§€λ‚λ©΄ μ •μƒμΆ…λ£ λλ„λ΅ λ‘κ°€μ§€ μΌ€μ΄μ¤λ¥Ό κ²€μ¦ν•©λ‹λ‹¤.
μΆ…λ£λ BalancerGroupμ—μ„ ExitIdleμ΄ ν•μ„ balancerμ— μ „νλμ§€ μ•λ” κ²ƒμ΄ μ •μƒ λ™μ‘μ΄κΈ° λ•λ¬Έμ— exitIdleChκ°€ μ‹ νΈλ¥Ό λ°›μΌλ©΄ ν…μ¤νΈλ” μ‹¤ν¨ν•©λ‹λ‹¤.

μ‹¤μ λ΅ ExitIdle κµ¬ν„μ„ λ³΄λ©΄ balancer groupμ΄ λ‹«ν ν›„μ—” early return ν›„ graceful ν•κ² μ²λ¦¬λλ” κ²ƒμ„ ν™•μΈν•  μ μμµλ‹λ‹¤.

``` go
// ExitIdle starts the balancing picker for use and exits idle mode.
func (bg *BalancerGroup) ExitIdle() {
    bg.outgoingMu.Lock()
    defer bg.outgoingMu.Unlock()
    if bg.outgoingClosed {
        return
    }
    for _, config := range bg.idToBalancerConfig {
        config.exitIdle()
    }
}
```

μ„ 3κ°μ ν…μ¤νΈμ½”λ“μ™€ μ μ‚¬ν• λ©”μ»¤λ‹μ¦μΌλ΅ λ‚λ¨Έμ§€ μƒν™©μ— λ€ν•΄μ„λ„ ν…μ¤νΈ μ½”λ“λ¥Ό μ‘μ„±ν–κ³  PR μ„ λ§λ¬΄λ¦¬ ν•  μ μμ—μµλ‹λ‹¤.


## 3. λ§λ¬΄λ¦¬
grpc-go λ‚΄λ¶€ λ©”μ»¤λ‹μ¦ μ¤‘ BalancerGroup κ³Ό ExitIdle μ λ™μ‘μ›λ¦¬λ¥Ό μ΄ν•΄ν•κ³  λ‹¤μ–‘ν• μ‹λ‚λ¦¬μ¤μ— λ€ν• ν…μ¤νΈ μ½”λ“λ¥Ό μ‘μ„±ν•  μ μλ” PR μ΄μ—μµλ‹λ‹¤.
λ¦¬λ·°λ¥Ό λ°›κΈ° μ „ channel λ€μ‹  variable μ„ μ‚¬μ©ν•΄ κ²€μ¦ μ½”λ“λ¥Ό μ‘μ„±ν–μ„ λ• λ‹¤μκ³Ό κ°™μ€ λ¦¬λ·°λ¥Ό λ°›κ² λμµλ‹λ‹¤.
![img.png](/img.png)
κ°„λ‹¨ν λ§ν•λ©΄ λ³€μ λ€μ‹  μ±„λ„μ„ μ‚¬μ©ν•λ€ λ§μΈλ°, grpc μ²λΌ λ‚΄λ¶€μ μΌλ΅ λ§μ€ κ³ λ£¨ν‹΄μ„ μ‚¬μ©ν•λ” λΌμ΄λΈλ¬λ¦¬λ¥Ό ν…μ¤νΈν•  λ• race condition μ— λ€ν• κ³ λ ¤λ„
ν•„μ”ν•κΈ° λ•λ¬Έμ— λ‚΄λ¶€μ μΌλ΅ λ™κΈ°ν™”κ°€ λ³΄μ¥λλ” channel μ„ μ‚¬μ©ν•΄μ•Ό ν•λ‹¤λ” κ²ƒλ„ μ• μ μμ—μµλ‹λ‹¤.



