---
title: "raft consensus algorithm"
date: 2024-07-14
desc: FE 개발자라면 티스토리 말고 개인 블로그 하나쯤은,,
thumbnail: /team-member-1.jpeg
category: System
---

# Raft 합의 알고리즘
- 분산시스템 환경에서 모든 노드가 동일한 상태를 유지하도록 하고,
일부 노드에 결함이 생기더라도 전체 시스템이 문제없이 동작하도록 만들기 위해 고안된 합의 알고리즘의 일종.
- 카프카 2.8버전부터 도입, 쿠버네티스의 etcd 클러스터, MongoDB의 레플리카 셋 등 다양한 영역에 접목되어 활용됨.

## 배경
위키피디아 참조

## 동작원리
래프트 합의가 적용된 분산 시스템의 모든 노드는 아래의 세가지 중 하나의 상태를 가짐.
일반적으로 하나의 리더와 나머지 참가자는 팔로워로 구성되며, 후보자는 리더가 없거나 무응답 상태일 경우에 일시적으로만 존재한다.
1. 리더
클러스터를 대표하는 노드로, 클라이언트가 클러스터로 보낸 모든 명령의 수신 및 전파, 응답을 전담한다.
리더는 주기적으로 자신의 상태 메시지(heartbeat) 를 팔로워에게 전파한다.
설정된 타임아웃 전에 하트비트를 참가자가 받지못하면 리더 선출과정으로 돌입한다.

2. 팔로워
리더가 존재하는 동안(임기) 나머지 노드는 팔로워 상태를 유지한다. 리더로부터 전파된 명령을 처리하는 역할을 담당한다.

3. 후보자
리더가 없는 상태에서, 새로운 리더를 정하기 위해 전환된 팔로워의 상태를 의미한다.

래프트에선 클러스터 전체에 대한 명령이 리더로부터 팔로워에게 일방향으로 전파된다.

## 래프트
- 래프트에서 각 노드는 다음 중 하나의 역할을 수행함
- 후보자
- 리더 역할은 일시적으로 유지되며 어떤 노드라도 리더가 될 수 있다.
- 리더가 되기 위해 노드는 후보자 상태로 전환하고 과반의 표를 얻어야 한다.
- 만약 어떤 후보자도 과반의 표를 얻지 못하면 새로운 임기를 시작하고 선출 과정을 다시 시작한다.
- 리더
- 클러스터 리더는 클라이언트의 요청을 처리하고 복제된 상태 기계(노드를 말하는건가?)와 상호 작용한다.
- 리더는 임기 동안 역할을 유지하고, 임기는 순차 증가하는 숫자로 식별된다.
- 네트워크 파티션 또는 메시지 지연으로 인해 장애가 발생했다고 판단되면 새로운 리더를 선출한다.
- 팔로워
- 로그를 저장하고 리더와 후보자의 요청에 응답하는 수동적인 참가자.
- 모든 참가자는 팔로워로 시작한다.

### 래프트 알고리즘의 수행 단계
- 후보자 P1 은 RequestVote 메시지를 모든 참가자에 전송
- 과반의 표를 얻은 후보자는 현재 임기의 리더로 선출된다. 참가자는 최대 하나의 후보자를 선택할 수 있다.
- 주기적 하트비트
- 래프트는 하트비트 메커니즘으로 참가자의 라이브니스를 보장한다.
- 설정된 타임아웃 전에 팔로워가 하트비트를 받지 못하면, 리더에 장애가 발생한것으로 판단하고 새로운 리더를 선출한다.
- 로그 복제 / 브로트캐스트
- 리더는 AppendEntries 메시지를 보내 로그에 새로운 항목을 추가할 수 있다.
- 메시지에는 리더의 임기, 인덱스, 직전에 전송한 로그의 임기, 하나 이상의 새로운 힝목을 포함한다.

### 래프트의 리더
- 모든 커밋된 항목이 저장된 노드만이 리더가 될 수 있다.
- 선출 과정에서 팔로워의 로그가 후보자보다 더 최신일 경우 팔로워는 투표를 거부한다. (후보자의 로그에 커밋된 항목이 최신이 아니기 때문)
- 선출된 리더는 클라의 요청을 수신하고 팔로워에 전달한다. 자신의 로그에 새로운 항목을 추가하고 모든 팔로워에 병렬로 전송한다.


### 리더 선출
- 임기 : 에포크 아님?
- 선거 타임아웃 : 팔로워 상태의 노드가 후보자로 전환되기 까지 대기하는 시간으로, 일종의타이머 역할을 한다.
이 타임아웃은 모든 팔로워 및 후보자 노드에게 각기 다른 임의의 값으로 주어진다. -> **이유는?**
- 하트비트 (Heartbeat) : 리더가 다른 모든 팔로워에게 일정 시간 간격으로 반복 전달하는 메시지로, 메시지에는 클라이언트의 명령 전파를 위한 로그가 포함되지 않으며, 오직 리더가 자신의 상태를 유지하는 수단으로만 가능하다.


이제 리더 선출(Leader Election)의 과정을 살펴보자.

1. 클러스터에 리더가 없는 상태에선 모든 노드가 팔로워 상태를 유지하며
각자에게 주어진 선거 타임아웃(Election Timeout)이 될 때까지 대기한다.
2. 선거 타임아웃(Election Timeout)이 가장 먼저 끝난 노드가 후보자로 전환되고,
새로운 선거 임기(Term)가 시작된다. 후보자 노드는 즉시 자신에게 한 표를 준 뒤 다른 노드들에게 투표 요청 메시지를 전송한다.
3. 만약 이 요청 메시지를 수신한 노드가 해당 임기 중에 아직 투표한 적이 없다면,
그 메시지의 발신처인 후보자에게 투표 메시지를 보낸 후 자신의 선거 타임아웃(Election Timeout)을 초기화한다.
이는 현재 투표 과정에 있는 후보자 노드(들) 외에 또다른 후보자가 출현하지 않도록 하는 장치다.
4. 전체 노드 수의 과반에 해당하는 응답을 얻은 노드는 해당 임기(Term)에 대한 새로운 리더로 선정된다.
- 새로 선출된 리더는 나머지 노드에게 하트비트를 주기적으로 전송한다.
- 팔로워는 리더로부터 하트비트를 수신할 때마다 자신의 선거 타임아웃을 다시 초기화하며 팔로워 상태를 유지한다.

### 리더에 문제가 생기면?
- 자신에게 주어진 선거 타임아웃 내에 하트비트를 수신받지 못하면 팔로워 노드는 즉시 후보자로 전환된다.
이 때 클러스터의 임기 번호가 1 증가하며, 곧바로 새로운 리더 선출 작업이 시작된다.
클러스터의 각 노드는 현재의 임기 번호를 저장해두고, 노드간 메시지를 주고받을 때 마다 이 번호를 포함시킨다.
문제가 생겼던 이전의 리더(ex-리더) 노드가 복구되어 클러스터와 다시 연결되면, 이 노드는 클러스터가 공유하는 임기 번호를 자신의 번호와 비교하게 된다.
현재 클러스터의 임기 번호보다 자신의 임기 번호가 낮은 것을 확인한 ex-리더는 팔로워로 전환된다.

### 만약 누구도 과반을 얻지 못하면?
- 리더 선출 시 재선거를 치뤄야 하는 경우가 종종 발생한다.
클러스터에서 우연히 2개의 후보자가 동시에 나타나 각 2표씩 얻은 경우를 상상해볼 수 있다.
분할 투표(split votes) 현상으로 인해 누구도 과반을 얻지 못한 경우엔 그대로 해당 임기를 종료하고 새임기와 함께 재선거를 시작한다.
이땐 이전처럼 분할 투표 현상이 발생하는 것을 방지하기 위해
호보자 노드들의 선거 타임아웃(election timeout) 값을 랜덤하게 재조정한다.(이건 DB Internals 더 찾아보자. 본 내용인듯)



### 정족수
- 정족수야.

ref)
* https://towardsdatascience.com/raft-algorithm-explained-a7c856529f40
* https://www.usenix.org/system/files/conference/atc14/atc14-paper-ongaro.pdf
* https://seongjin.me/raft-consensus-algorithm/
- https://medium.com/curg/raft-consensus-%EC%9D%B4%ED%95%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%95%A9%EC%9D%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%97%AC%EC%A0%95-f7ecb9f450ab?ref=seongjin.me
- DB Internals [chapter 14]
